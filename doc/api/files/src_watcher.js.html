<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>src/watcher.js - watcher.js</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="icon" href="../assets/favicon.ico">
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
                <h1><img src="../assets/css/logo.png" title="watcher.js" width="117" height="52"></h1>
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: 1.0.0</em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
                    <h2 class="off-left">APIs</h2>
                    <div id="api-tabview" class="tabview">
                        <ul class="tabs">
                            <li><a href="#api-classes">Classes</a></li>
                            <li><a href="#api-modules">Modules</a></li>
                        </ul>
                
                        <div id="api-tabview-filter">
                            <input type="search" id="api-filter" placeholder="Type to filter APIs">
                        </div>
                
                        <div id="api-tabview-panel">
                            <ul id="api-classes" class="apis classes">
                                <li><a href="../classes/AbstractConnector.html">AbstractConnector</a></li>
                                <li><a href="../classes/Dictionary.html">Dictionary</a></li>
                                <li><a href="../classes/DictionaryFactory.html">DictionaryFactory</a></li>
                                <li><a href="../classes/EventDispatcher.html">EventDispatcher</a></li>
                                <li><a href="../classes/EventDispatcherFactory.html">EventDispatcherFactory</a></li>
                                <li><a href="../classes/HttpConnector.html">HttpConnector</a></li>
                                <li><a href="../classes/HttpConnectorFactory.html">HttpConnectorFactory</a></li>
                                <li><a href="../classes/Logger.html">Logger</a></li>
                                <li><a href="../classes/OnConnectionResolution.html">OnConnectionResolution</a></li>
                                <li><a href="../classes/OnConnectionResolutionFactory.html">OnConnectionResolutionFactory</a></li>
                                <li><a href="../classes/ResolutionStrategy.html">ResolutionStrategy</a></li>
                                <li><a href="../classes/ResolutionStrategyFactory.html">ResolutionStrategyFactory</a></li>
                                <li><a href="../classes/ResolverEvents.html">ResolverEvents</a></li>
                                <li><a href="../classes/ServiceStatus.html">ServiceStatus</a></li>
                                <li><a href="../classes/SocketConnector.html">SocketConnector</a></li>
                                <li><a href="../classes/SocketConnectorFactory.html">SocketConnectorFactory</a></li>
                                <li><a href="../classes/StatusResolver.html">StatusResolver</a></li>
                                <li><a href="../classes/StatusResolverFactory.html">StatusResolverFactory</a></li>
                                <li><a href="../classes/Validator.html">Validator</a></li>
                                <li><a href="../classes/Watcher.html">Watcher</a></li>
                                <li><a href="../classes/WatcherFactory.html">WatcherFactory</a></li>
                                <li><a href="../classes/WatcherHttp.html">WatcherHttp</a></li>
                            </ul>
                
                            <ul id="api-modules" class="apis modules">
                                <li><a href="../modules/connectors.html">connectors</a></li>
                                <li><a href="../modules/constants.html">constants</a></li>
                                <li><a href="../modules/httpServer.html">httpServer</a></li>
                                <li><a href="../modules/logger.html">logger</a></li>
                                <li><a href="../modules/resolvers.html">resolvers</a></li>
                                <li><a href="../modules/utils.html">utils</a></li>
                                <li><a href="../modules/validator.html">validator</a></li>
                                <li><a href="../modules/watcher.html">watcher</a></li>
                                <li><a href="../modules/watcher-http.html">watcher-http</a></li>
                            </ul>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
                    Show:
                    <label for="api-show-inherited">
                        <input type="checkbox" id="api-show-inherited" checked>
                        Inherited
                    </label>
            
                    <label for="api-show-protected">
                        <input type="checkbox" id="api-show-protected">
                        Protected
                    </label>
            
                    <label for="api-show-private">
                        <input type="checkbox" id="api-show-private">
                        Private
                    </label>
                    <label for="api-show-deprecated">
                        <input type="checkbox" id="api-show-deprecated">
                        Deprecated
                    </label>
            
                </div>
            
            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
<h1 class="file-heading">File: src/watcher.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
/**
 * Created by jpsoroulas.
 */
/**
 * ###Overview
 * This is the main application module. It provides the factory method for creating an application,
 * the so called __watcher.js__, that can be used to monitor service status.
 * The application architecture is very simple. At regular intervals (_service communication interval_),
 * service specific defined messages, either as http requests or as raw data to sockets (depending on the
 * communication type of the service endpoint), are send to the monitored services, or to be more precise are send
 * to the service endpoints (or simply endpoints), to find out their status (the _service_ and  endpoint_ notation
 * is used interchangeably, but there is a conceptual difference between them which will be discussed shortly).
 * On the service status resolution, the status is stored internally and is made available either programmatically or
 * via http requests (aka the _status requests_).
 * Actually, __the entire application API is exposed as a set of HTTP requests__, which, on top of this, a simple but handy
 * __web gui__ is implemented. For the HTTP interface implementation the [express](http://expressjs.com) web framework is used.
 * At the following paragraphs the http interface is described with references to the respective application API.
 *
 * * A _status request_ for a specific endpoint
 *  * __http://&#x60;&lt;host&gt;&#x60;:&#x60;&lt;port&gt;&#x60;/endpoint/&#x60;&lt;id&gt;&#x60;__ (request method: GET),
 *  * parameters:
 *    * __id__ the endpoint id, it should be one of those defined at endpoints configuration data,
 *  * API reference: __{{#crossLink &quot;Watcher/getEndpoint:method&quot;}}{{/crossLink}}__.
 *
 * The response is a JSON message like the following example:
 *
 * &#x60;&#x60;&#x60;
 * // For a socket communication type
 * {
 *      &quot;id&quot;: &quot;endpoint-id&quot;,            // endpoint id
 *      &quot;desc&quot;: &quot;an endpoint&quot;,          // endpoint description
 *      &quot;status&quot;: &quot;up&quot;,                 // endpoint status
 *      &quot;timestamp&quot;: 1429860936846,     // the timestamp of the current status
 *      &quot;since&quot;: 1429860926846,         // the timestamp since the last change of status
 *      &quot;type&quot;: &quot;socket&quot;,               // connector type
 *      &quot;host&quot;: &quot;localhost&quot;,            // endpoint host (applied for &#x27;socket&#x27; connector)
 *      &quot;port&quot;: 7777,                   // endpoint port (applied for &#x27;socket&#x27; connector)
 *      &quot;active&quot;: true,                 // whether or not the endpoint is active
 *      &quot;notify&quot;: false                 // whether or not the notification is enabled
 * }
 * &#x60;&#x60;&#x60;
 *
 * * A status request for all registered endpoints.
 *  * __http://&#x60;&lt;host&gt;&#x60;:&#x60;&lt;port&gt;&#x60;/endpoints__ (request method: GET).
 *  In this case the response JSON message is an array with the information for all endpoints.
 *  * API reference: __{{#crossLink &quot;Watcher/getEndpoints:method&quot;}}{{/crossLink}}__.
 *
 * &#x60;&#x60;&#x60;
 * // For a socket and http communication types
 * [
 *      {
 *          &quot;id&quot;: &quot;endpoint-1&quot;,
 *          &quot;desc&quot;: &quot;endpoint 1&quot;,
 *          &quot;status&quot;: &quot;down&quot;
 *          &quot;timestamp&quot;: 1429860936846,
 *          &quot;since&quot;: 1429860926846,
 *          &quot;type&quot;: &quot;socket&quot;,
 *          &quot;host&quot;: &quot;localhost&quot;,
 *          &quot;port&quot;: 7777,
 *          &quot;active&quot;: true,
 *          &quot;notify&quot;: true
 *      },
 *      {
 *          &quot;id&quot;: &quot;endpoint-2&quot;,                     // endpoint id
 *          &quot;desc&quot;: &quot;endpoint 2&quot;,                   // endpoint description
 *          &quot;status&quot;: &quot;up&quot;                          // endpoint status
 *          &quot;timestamp&quot;: 1429860936846,             // the timestamp of the current status
 *          &quot;since&quot;: 1429860926846,                 // the timestamp since the last change of status
 *          &quot;type&quot;: &quot;http&quot;,                         // connector type
 *          &quot;url&quot;: &quot;http://11.222.333.555:3333/&quot;,   // endpoint url (applied for &#x27;http(s) connector&#x27;)
 *          &quot;active&quot;: true,                         // whether or not the endpoint is active
 *          &quot;notify&quot;: false                         // whether or not the notification is enabled
 *      }
 * ]
 * &#x60;&#x60;&#x60;
 *
 * * Add new endpoint.
 *  * __http://&#x60;&lt;host&gt;&#x60;:&#x60;&lt;port&gt;&#x60;/endpoint/add__ (request method POST)
 *  * parameters (parameters in _[]_ are optional. when not set, the default values are used - those in parentheses.):
 *    * __id__ : the endpoint id,
 *    * __desc__ : the endpoint description,
 *    * __type__ : the endpoint type (&#x27;socket&#x27; or &#x27;http&#x27;),
 *    * [__host__] (localhost): the endpoint host (applied for &#x27;socket&#x27; communication type),
 *    * [__port__] (9999): the endpoint port (applied for &#x27;socket&#x27; communication type),
 *    * [__url__] : the endpoint port (applied for &#x27;http&#x27; communication type),
 *    * [__active__] (true): true/false whether or not to activate the endpoint,
 *    * [__notify__] (false): true/false whether or not to enable email notification on erroneous service status
 *  * API reference: __{{#crossLink &quot;Watcher/addEndpoint:method&quot;}}{{/crossLink}}__.
 *
 *
 * * Remove an endpoint
 *  * __http://&#x60;&lt;host&gt;&#x60;:&#x60;&lt;port&gt;&#x60;/endpoint/remove__ (request method POST),
 *  * parameters:
 *    * __id__ : the endpoint id
 *  * API reference: __{{#crossLink &quot;Watcher/removeEndpoint:method&quot;}}{{/crossLink}}__.
 *
 *
 * * Activate/deactivate an endpoint
 *  * __http://&#x60;&lt;host&gt;&#x60;:&#x60;&lt;port&gt;&#x60;/endpoint/activation__ (request method POST),
 *  * parameters:
 *    * __id__ : the endpoint id,
 *    * __activate__ : true/false whether to activate or not the endpoint
 *  * API reference: __{{#crossLink &quot;Watcher/setEndpointActivationState:method&quot;}}{{/crossLink}}__.
 *
 *
 * * Enable/disable notification for an endpoint
 *  * __http://&#x60;&lt;host&gt;&#x60;:&#x60;&lt;port&gt;&#x60;/endpoint/notification__ (request method POST),
 *  * parameters:
 *    * __id__ : the endpoint id,
 *    * __notify__ : true/false whether or not to enable email notification on erroneous service status
 *  * API reference: __{{#crossLink &quot;Watcher/notifyOnErroneousStatus:method&quot;}}{{/crossLink}}__.
 *
 *
 * * Get the ids of the unbound resolution strategies
 *  * __http://&#x60;&lt;host&gt;&#x60;:&#x60;&lt;port&gt;&#x60;/resolution-strategies__ (request method GET),
 *  * API reference: __{{#crossLink &quot;Watcher/getResolutionStrategies:method&quot;}}{{/crossLink}}__.
 *
 *
 * * __http://&#x60;&lt;host&gt;&#x60;:&#x60;&lt;port&gt;&#x60;/console__, a web graphical user interface for the monitored services. The _console_ exposes
 * the _watcher.js_ API through a simple user-friendly gui.
 *
 *
 * ###Configuration
 * The application configuration requires two kinds of data, as shown below. The one that refers to the
 * express framework that implements the application http interface, and the other that refers to the service
 * endpoints. Note that properties in _[]_ are optional. when not set, the default values are used - those in parentheses.
 *
 *
 * * Embedded http server configuration and service communication interval
 *  * [__host__] (&#x27;localhost&#x27;), the http server host name.
 *  * [__port__] (7777), the http server port.
 *  * [__interval__] (10000 ms), the regular interval, at ms, that the application attempts to establish
 *  communication with the services to resolve their status (_service communication interval_).
 *  * [__routeExts__], an array of user defined route extensions for building custom responses for the status requests.
 *  A route extension should be a function that accepts the __{{#crossLink &quot;Watcher/_registry:property&quot;}}{{/crossLink}}__
 *  as parameter and return a function that conforms to [express route](http://expressjs.com/guide/routing.html) conventions
 *  (a function with parameters: _req_, _res_, _next_, as shown at the examples)
 *  * [__resolutionStrategies__], an array of objects (aka unbound resolution strategy descriptor), each of them holds the
 *  information for an _unbound resolution strategy_ (__{{#crossLinkModule &quot;resolvers&quot;}}{{/crossLinkModule}}__) to be registered
 *  at the system. These strategies are not bound to any endpoint, but they can be associated with them by setting the
 *  respective strategy id at the endpoint&#x27;s _resolutionStrategy_ configuration property (see at endpoint configuration below).
 *  The descriptor is an object as follows:
 *  &#x60;&#x60;&#x60;
 *  {
 *      id: &lt;the resolution strategy id&gt;, (should be unique)
 *      desc: &lt;the resolution strategy description&gt;
 *      implementation: &lt;the implementation of resolution strategy&gt; (see at resolvers to see the interface)
 *  }
 *  &#x60;&#x60;&#x60;
 *  * [__nfOpts__], the notification options. Holds the information of the sender and the email addresses
 *  to receive email when erroneous service status occurs. The default sender is _admin@watcherjs.com_
 *  (if needed, configure your email account to not filter this sender as a spam). The object structure is:
 *  &#x60;&#x60;&#x60;
 *  {
 *      sender: &lt;the sender&gt;, // default value: admin@watcherjs.com
 *      recipients: [&lt;recipient1&gt;, &lt;recipient1&gt;, ...] // the array of recipients email
 *  }
 *  &#x60;&#x60;&#x60;
 *  * [__exportDir__] (_&lt;&#x60;project directory&#x60;&gt;/storage/_), the storage directory of dynamically created endpoints.
 *
 *
 * * Endpoint
 *  * __id__, the unique endpoint/service id. This _id_ is used for the service identification when a service request is made.
 *  * __type__, the endpoint type, the type determines whether the message
 *  exchange is performed via http requests or directly with the socket. It actually dictates the underline
 *  connector used for the specific service (see also at __{{#crossLinkModule &quot;connectors&quot;}}{{/crossLinkModule}}__).
 *  The permitted values are: __&#x27;socket&#x27;__ and __&#x27;http&#x27;__ for __{{#crossLink &quot;SocketConnector&quot;}}{{/crossLink}}__
 *  and __{{#crossLink &quot;HttpConnector&quot;}}{{/crossLink}}__ respectively.
 *  * [__desc__] (__id__), the endpoint description.
 *  * [__host__] (localhost), the endpoint hostname when a __{{#crossLink &quot;SocketConnector&quot;}}{{/crossLink}}__ is used.
 *  * [__port__] (9999), the endpoint port when a __{{#crossLink &quot;SocketConnector&quot;}}{{/crossLink}}__ is used.
 *  * [__url__] (http://localhost:8080), the endpoint url when __{{#crossLink &quot;HttpConnector&quot;}}{{/crossLink}}__ is used.
 *  * [__timeout__] (5000), the applied connector&#x27;s connection timeout (see also at
 *  __{{#crossLink &quot;SocketConnectorFactory/create:method&quot;}}{{/crossLink}}__ and
 *  __{{#crossLink &quot;HttpConnectorFactory/create:method&quot;}}{{/crossLink}}__).
 *  * [__resolutionStrategy__] (__{{#crossLink &quot;OnConnectionResolution&quot;}}{{/crossLink}}__) the applied resolution strategy.
 *  This property can hold either an implementation of a resolution strategy or the id of the an unbound strategy.
 *  * [__active__] (true), used to indicate whether or not the endpoint should be activated
 *  (enables or suspends the communication between the respective connector and the endpoint).
 *  * [__notify__] (false), used to indicate whether or not to receive email notifications for erroneous service status.
 *
 *
 * The _endpoint_ notation is used to emphases that the _service_ can be proxied by another service (_the proxy_) which
 * is that determines the status of the proxied service. In this case, the endpoint belongs to the proxy and not to the
 * monitored service.
 *
 *
 * ###Exported objects
 * * __{{#crossLink &quot;WatcherFactory&quot;}}{{/crossLink}}__
 *
 * ###API Usage samples
 * __Service with route extension and resolution strategy registration__
 *    &#x60;&#x60;&#x60;javascript
 * // Here is the configuration of three endpoints. Two of them are accessed via sockets and refer to the services
 * // &#x27;service-1&#x27; and &#x27;service-2&#x27; hosted at &#x27;11.222.333.444&#x27; and &#x27;11.222.333.555&#x27; respectively, whereas the other is
 * // accessed via http and refers to the service &#x27;service-3&#x27; that is also hosted at &#x27;11.222.333.555&#x27; (note that we use
 * // the notation _service_ since the _endpoint_ and the _service_ is the same component).
 * // Fix the module paths
 * var watcher = require(&#x27;watcher&#x27;);
 * var constants = require(&#x27;constants&#x27;);
 * var resolvers = require(&#x27;resolvers&#x27;);
 *
 * var down = constants.serviceStatus.down;
 * var watcherFactory = watcher.watcherFactory;
 * var onConnectionResolutionFactory = resolvers.onConnectionResolutionFactory;
 *
 * var alwaysDownStrategy = {
 *       reset: function reset() {},
 *       resolveOnConnection: function resolveOnConnection(connection) {
 *          //mark as down only for demonstration purposes
 *           return down;
 *       },
 *       resolveOnConversation: function resolveOnConnection(connection) {},
 *       resolveNow: function resolveOnConnection(connection) {}
 *   };
 *
 * var options = {
 *     port: 7777,
 *     interval: 15000,
 *    routeExts: [{
 *          path: &#x27;/custom-route&#x27;,
 *          route: function service(registry) {
 *              return function (req, res, next) {
 *                  var id = req.query.id;
 *                  var record = registry[id];
 *                  if (record) {
 *                      res.send(&#x27;Service status: &#x27; + record.status);
 *                  } else {
 *                      res.send(&#x27;Unknown service: &#x27; + id);
 *                  }
 *              };
 *          }
 *      }],
 *     resolutionStrategies: [
 *           {// Actually the default implementation, added for demonstration purposes
 *               id: &#x27;on-connection&#x27;,
 *               desc: &#x27;resolution on connection&#x27;,
 *               implementation: onConnectionResolutionFactory.create()
 *           },
 *           {
 *               id: &#x27;always-down&#x27;,
 *               desc: &#x27;always down&#x27;,
 *               implementation: alwaysDownStrategy
 *           }
 *       ],
 *     nfOpts: {
 *          recipients: [&#x27;foo@foo.com&#x27;]
 *      },
 *     endpoints: [
 *          {
 *              id: &#x27;service-1&#x27;,
 *              desc: &#x27;service 1&#x27;,
 *              type: &#x27;socket&#x27;,
 *              host: &#x27;11.222.333.444&#x27;,
 *              port: 1234,
 *              // Apply an implementation of resolution strategy
 *              resolutionStrategy: alwaysDownStrategy,
 *              active: true,
 *              notify: true
 *          },
 *          {
 *              id: &#x27;service-2&#x27;,
 *              desc: &#x27;service 2&#x27;,
 *              type: &#x27;socket&#x27;,
 *              host: &#x27;11.222.333.555&#x27;,
 *              port: 1234,
 *              // Apply the unbound resolution strategy with id &#x27;on-connection&#x27;
 *              resolutionStrategy: &#x27;on-connection&#x27;,
 *              active: true,
 *              notify: true
 *          },
 *          {
 *              id: &#x27;service-3&#x27;,
 *              desc: &#x27;service 3&#x27;,
 *              type: &#x27;http&#x27;,
 *              timeout: 3000,
 *              // The query string could be anything
 *              url: &#x27;http://11.222.333.555:3333/?get-status&#x27;,
 *              active: true,
 *              notify: true
 *          }
 *      ]
 *  };
 * watcherFactory.create(options).start();
 *
 * After starting the watcher the following status requests could be made in order to
 * retrieve the status for the services with id &#x27;service-1&#x27;, &#x27;service-2&#x27; and &#x27;service-3&#x27; respectively
 * http://localhost:7777/endpoint/service-1
 * http://localhost:7777/endpoint/service-2
 * http://localhost:7777/endpoint/service-3
 * Whereas the request http://localhost:7777/custom-route?id=service-1
 * is the user defined route which returns: &#x27;Service status: &lt;status&gt;&#x27; where status
 * the status of the &#x27;service-1&#x27;.
 *    &#x60;&#x60;&#x60;
 * __Proxied services__
 *    &#x60;&#x60;&#x60;javascript
 * // Proxied services
 * // Here is the case where a proxy controls the status of two service (e.g. _proxied-service-1_
 * // and _proxied-service-2_). The proxy is hosted at &#x27;11.222.333.444&#x27; and can be accessed via http.
 * // Two http endpoints at the proxy are created, the &#x27;endpoint-1&#x27; and &#x27;endpoint-2&#x27; each one of them
 * // is connected with the respective monitored proxied services (note that we use the notation _endpoint_ since
 * // the _endpoint_ is not the monitored _service_).
 *
 * // Fix the module paths
 * var watcherFactory = require(&#x27;watcher&#x27;).watcherFactory;
 * var options = {
 *     port: 7777,
 *     interval: 15000,
 *     endpoints: [
 *          {
 *              id: &#x27;endpoint-1&#x27;,
 *              type: &#x27;http&#x27;,
 *              timeout: 3000,
 *              // request to the proxied service &#x27;proxied-service-1&#x27;, the query string could be anything
 *              url: &#x27;http://11.222.333.444:3333/?get-status-for=proxied-service-1&#x27;
 *          },
 *          {
 *              id: &#x27;endpoint-2&#x27;,
 *              type: &#x27;http&#x27;,
 *              timeout: 3000,
 *              // request to the proxied service &#x27;proxied-service-2&#x27;, the query string could be anything
 *              url: &#x27;http://11.222.333.444:3333/?get-status-for=proxied-service-2&#x27;
 *          }
 *      ]
 *  };
 * watcherFactory.create(options).start();
 *
 * After starting the watcher the following status requests could be made in order to
 * retrieve the status for &#x27;proxied-service-1&#x27; and &#x27;proxied-service-2&#x27; respectively
 * http://localhost:7777/endpoint/endpoint-1
 * http://localhost:7777/endpoint/endpoint-2
 *    &#x60;&#x60;&#x60;
 *
 * __Add and remove endpoints dynamically__
 *    &#x60;&#x60;&#x60;javascript
 * // Here is an example for dynamically adding and removing endpoints
 *
 * // Fix the module paths
 * var watcherFactory = require(&#x27;watcher&#x27;).watcherFactory;
 * var options = {
 *     port: 7777,
 *     interval: 15000,
 *     endpoints: [
 *          {
 *              id: &#x27;service-1&#x27;,
 *              type: &#x27;socket&#x27;,
 *              host: &#x27;11.222.333.444&#x27;,
 *              port: 1234
 *          }
 *      ]
 *  };
 * var watcher = watcherFactory.create(options).start();
 *
 * // Add the endpoint &#x27;service-2&#x27;
 * setTimeout(function() {
 *        watcher.addEndpoint({
 *          id: &#x27;service-2&#x27;,
 *          type: &#x27;http&#x27;,
 *          timeout: 3000,
 *          url: &#x27;http://11.222.333.555:3333/?get-status&#x27;
 *      });
 *      if (!_.isEmpty(errors)) {
 *          throw new Error(&#x27;validation error...&#x27;);
 *      }
 * }, 6000);
 *
 * // Deactivate the endpoint &#x27;service-2&#x27;
 * setTimeout(function () {
 *      watcher.deactivateEndpoint(&#x27;service-2&#x27;);
 * }, 12000);
 *
 * // Activate the endpoint &#x27;service-2&#x27;
 * setTimeout(function () {
 *        watcher.activateEndpoint(&#x27;service-2&#x27;);
 *   }, 30000);
 *
 * // Remove the endpoint &#x27;service-2&#x27;
 * setTimeout(function() {
 *       watcher.removeEndpoint(&#x27;service-2&#x27;);
 * }, 60000);
 *
 * // Shutdown the application
 * setTimeout(function () {
 *      watcher.stop();
 * }, 120000);
 *
 *    &#x60;&#x60;&#x60;
 * @module watcher
 */
&#x27;use strict&#x27;;
var fs = require(&#x27;fs-extra&#x27;);
var events = require(&#x27;events&#x27;);
var path = require(&#x27;path&#x27;);
var stampit = require(&#x27;stampit&#x27;);
var _ = require(&#x27;underscore&#x27;);
var moment = require(&#x27;moment&#x27;);
var nodemailer = require(&#x27;nodemailer&#x27;);
var directTransport = require(&#x27;nodemailer-direct-transport&#x27;);
//var http = require(&#x27;http&#x27;);
//var query = require(&#x27;connect-query&#x27;);
//var fs = require(&#x27;fs&#x27;);
//var connect = require(&#x27;connect&#x27;);
//var async = require(&#x27;async&#x27;);
//var s = require(&#x27;underscore.string&#x27;);

var logger = require(&#x27;./logger&#x27;);
var validator = require(&#x27;./validator&#x27;);
var constants = require(&#x27;./constants&#x27;);
var connectors = require(&#x27;./connectors&#x27;);
var httpServerFactory = require(&#x27;./http-server&#x27;);
//var utils = require(&#x27;./utils&#x27;);

var up = constants.serviceStatus.up;
var socketConnectorFactory = connectors.socketConnectorFactory;
var httpConnectorFactory = connectors.httpConnectorFactory;
var undetermined = constants.serviceStatus.undetermined;
var watcherConfigured = constants.watcherEvents.watcherConfigured;
var watcherReady = constants.watcherEvents.watcherReady;
var socketConnectorType = constants.connectorType.socket;
var httpConnectorType = constants.connectorType.http;

var watcher, watcherFactory;

function createConnector(endpoint) {
    var connector, type = endpoint.type;
    switch (type) {
        case socketConnectorType:
            connector = socketConnectorFactory.create(endpoint);
            break;
        case httpConnectorType:
            connector = httpConnectorFactory.create(endpoint);
            break;
        default:
            throw new Error(&#x27;Can not create connector type: &#x27; + type);
    }
    return connector;
}

/**
 * The application that can be used to monitor your services status.
 * An application overview and detailed configuration instructions and examples can be found at
 * __{{#crossLinkModule &quot;watcher&quot;}}{{/crossLinkModule}}__
 *
 * @class Watcher
 */
watcher = stampit().state({
    options: void 0,
    emitter: void 0
}).enclose(function () {
    // listen for terminal signal e.g. kill
    process.on(&#x27;SIGTERM&#x27;, _.bind(this.stop, this));

    // listen for interrupt signal e.g. Ctrl-C
    process.on(&#x27;SIGINT&#x27;, _.bind(this.stop, this));
    /**
     * Holds the registered endpoints.
     *
     * @private
     * @property _registry
     * @type Object
     */
    this._registry = {};

    this._transporter = nodemailer.createTransport(directTransport({}));

    this._passive = false;
}).methods({
        /**
         * Registers an endpoint.
         *
         * @private
         * @method _registerEndpoint
         * @param {Object} endpoint the endpoint.
         */
        _registerEndpoint: function _registerEndpoint(endpoint) {
            var now = moment.utc();
            var _record = {
                status: undetermined,
                timestamp: now,
                since: now,
                processed: false,
                active: true,
                notify: false
            };
            endpoint = _.clone(endpoint);
            var connector = createConnector(endpoint);
            var record = _.omit(_.defaults(endpoint, _record), &#x27;resolutionStrategy&#x27;);
            var id = record.id;
            record.desc = record.desc || id;
            record.connector = connector;
            // Register status resolved listener
            var listener = _.bind(_.partial(this._onStatusResolve, record), this);
            connector.addStatusResolvedListener(listener);

            this._registry[id] = record;
            logger.debug(&#x27;New endpoint registered: &#x27; + id);
            return record;
        },

        /**
         * Sends notification email if erroneous service status occurs.
         *
         * @private
         * @method _notify
         */
        _notify: function _notify() {
            var toBeNotified;
            var sender = this.options.nfOpts.sender;
            var recipients = this.options.nfOpts.recipients;
            if (!_.isEmpty(recipients)) {
                toBeNotified = _.filter(this._registry, function (record) {
                    var status = record.status;
                    if (record.active &amp;&amp; up !== status &amp;&amp; undetermined !== status) {
                        if (record.notify &amp;&amp; (status !== record.previousStatus || !record.notified)) {
                            return true;
                        }
                    } else {
                        record.notified = false;
                    }
                    return false;
                });

                if (!_.isEmpty(toBeNotified)) {
                    var msg = [];
                    _.each(toBeNotified, function (record) {
                        msg.push(&#x27;Endpoint, \&#x27;&#x27; + record.id + &#x27;\&#x27;, status: &#x27; + record.status +
                        &#x27;, timestamp: &#x27; + record.timestamp.format(&#x27;MMMM Do YYYY, h:mm:ss&#x27;));
                    });
                    msg = msg.join(&#x27;&#x27;);
                    this._transporter.sendMail({
                        from: sender,
                        to: recipients.join(&#x27;,&#x27;),
                        subject: &#x27;Notification&#x27;,
                        text: msg
                    }, function (error, response) {
                        if (error) {
                            logger.warn(&#x27;Notification message failed: &#x27; + error);
                        } else {
                            logger.info(&#x27;Notification message send: &#x27; + msg);
                            _.each(toBeNotified, function (record) {
                                record.notified = true;
                            });
                        }
                    });
                }

            }
        },

        _onStatusResolve: function _onStatusResolve(record, status) {
            if (!this._stopped) {
                record.timestamp = moment.utc();
                if(record.previousStatus !== record.status) {
                    record.since = record.timestamp;
                }
                record.previousStatus = record.status;
                record.status = status;
                record.processed = true;
                logger.debug(&#x27;Update registry, id/status: &#x27; + record.id + &#x27;/&#x27; + status);
                if (_.every(this._registry,
                        function (record) {
                            return (record.processed === true);
                        })) {
                    this._notify();
                    setTimeout(_.bind(this._pollEndpoints, this), this.options.interval).unref();
                }
            }
        },

        _pollEndpoints: function _pollEndpoints() {
            var _self = this;
            if (!_self._stopped) {
                var registry = _self._registry;
                _.each(registry, function (record) {
                    record.processed = false;
                });
                var passive = this._passive = _.every(registry, function (record) {
                    return !(record.active);
                });
                if (passive) {
                    logger.debug(&#x27;No active endpoints, system passivated.&#x27;);
                } else {
                    logger.debug(&#x27;Poll for services status...&#x27;);
                    _.each(registry, function (record) {
                        if (record.active) {
                            record.connector.start.call(record.connector);
                        } else {
                            record.processed = true;
                        }
                    });
                }
            }
        },

        /**
         * Activates the system again if it is passivated.
         *
         * @private
         * @method _restartIfPassive
         */
        _restartIfPassive: function _restartIfPassive() {
            if (true === this._passive) {
                logger.debug(&#x27;Active endpoint found, system activated.&#x27;);
                setTimeout(_.bind(this._pollEndpoints, this), 0).unref();
            }
        },

        /**
         * Stores endpoint at the persistence storage
         * (at the moment, the filesystem is used).
         *
         * @private
         * @method _persistEndpoint
         * @param {Object} endpoint the endpoint configuration.
         */
        _persistEndpoint: function _persistEndpoint(endpoint) {
            var fileName = path.join(this.options.exportDir, endpoint.id + &#x27;.json&#x27;);
            endpoint = _.clone(endpoint);
            var strategy = endpoint.resolutionStrategy;
            if (strategy) {
                endpoint.resolutionStrategy = strategy.id;
            }
            fs.outputJson(fileName, endpoint,
                function (err) {
                    if (err) {
                        logger.error(&#x27;Endpoint \&#x27;&#x27; + endpoint.id +
                        &#x27;\&#x27; configuration failed to be written at &#x27; + fileName +
                        &#x27;\n&#x27; + err);
                    } else {
                        logger.info(&#x27;Endpoint \&#x27;&#x27; + endpoint.id +
                        &#x27;\&#x27; configuration written at &#x27; + fileName);
                    }
                });
        },

        /**
         * Deletes the endpoint of the specified id from the persistence storage
         * (at the moment, the filesystem is used).
         *
         * @private
         * @method _deleteEndpoint
         * @param {String} id the endpoint id.
         */
        _deleteEndpoint: function _deleteEndpoint(id) {
            var fileName = path.join(this.options.exportDir, id + &#x27;.json&#x27;);
            fs.remove(fileName, function (err) {
                if (err) {
                    logger.error(&#x27;Unable to remove endpoint \&#x27;&#x27; + id +
                    &#x27;\&#x27; from storage: &#x27; + fileName + &#x27;\n&#x27; + err);
                } else {
                    logger.info(&#x27;Endpoint \&#x27;&#x27; + id +
                    &#x27;\&#x27; removed from storage: &#x27; + fileName);
                }
            });
        },

        /**
         * Stores endpoint info at persistence storage (currently, at the filesystem).
         *
         * @private
         * @method _getStoredEndpoints
         * @return {Array} the persistent endpoints.
         */
        _getStoredEndpoints: function _getStoredEndpoints() {
            var storage = path.normalize(this.options.exportDir);
            fs.ensureDirSync(storage, function (err) {
                if (err) {
                    logger.debug(&#x27;Unable to create endpoints storage directory: &#x27; +
                    storage + &#x27;\n&#x27; + err);
                } else {
                    logger.debug(&#x27;Ensuring existence of endpoints storage directory: &#x27; +
                    storage);
                }
            });
            var storedEnpoints = [];
            fs.readdirSync(storage).forEach(function (file) {
                var entry = path.join(storage, file);
                var stats = fs.statSync(entry);
                if (!stats.isDirectory()) {
                    var endpoint = fs.readJsonSync(entry, {throws: false});
                    if (!_.isNull(endpoint)) {
                        storedEnpoints.push(endpoint);
                        logger.info(&#x27;Get endpoint from storage: &#x27; + entry);
                    } else {
                        logger.warn(&#x27;Unable to construct endpoint from storage, invalid json file: &#x27; + entry);
                    }
                }
            });
            return storedEnpoints;
        },

        /**
         * Returns the endpoint with the specified id.
         *
         * @method getEndpoint
         * @param {String} id the endpoint id.
         */
        getEndpoint: function getEndpoint(id) {
            return this._registry[id];
        },

        /**
         * Returns the endpoints.
         *
         * @method getEndpoints
         * @return {Array} the endpoints.
         */
        getEndpoints: function getEndpoints() {
            return _.values(this._registry);
        },

        /**
         * Adds an endpoint with the specified configuration.
         * For the configuration see at {{#crossLinkModule &quot;watcher&quot;}}{{/crossLinkModule}}
         *
         * @method addEndpoint
         * @param {Object} endpoint the endpoint configuration (see at
         * __{{#crossLink &quot;WatcherFactory/create:method&quot;}}{{/crossLink}}__).
         * @param {Boolean} store used to indicate whether or not to store the endpoint.
         * @return {Array} the validation errors, empty if no error exists.
         * @throws {Error} validation errors.
         */
        addEndpoint: function addEndpoint(endpoint, store) {
            var registry = this._registry;
            var validationErrors = validator.validateServiceEndpoint(endpoint, _.keys(registry),
                this.options.resolutionStrategies);
            if (_.isEmpty(validationErrors)) {
                var record = this._registerEndpoint(endpoint);
                if (store) {
                    this._persistEndpoint(endpoint);
                }
                if (record.active) {
                    this._restartIfPassive();
                }
            } else {
                var error = &#x27;&#x27;;
                _.each(validationErrors, function (ve) {
                    error += (ve + &#x27;\n&#x27;);
                });
                //logger.error(&#x27;Unable to register service endpoint: &#x27; + id + &#x27;, &#x27; + error);
                throw new Error(error);
            }
        },

        /**
         * Removes the endpoint with the specified id.
         *
         * @method removeEndpoint
         * @param {String} id the endpoint id.
         */
        removeEndpoint: function removeEndpoint(id) {
            delete this._registry[id];
            this._deleteEndpoint(id);
            logger.debug(&#x27;Endpoint has been removed: &#x27; + id);
        },

        /**
         * Activate/Deactivates the endpoint with the specified id.
         *
         * @method setEndpointActivationState
         * @param {String} id the endpoint id.
         * @param {Boolean} active true or false to activate or deactivate the specific endpoint respectively.
         */
        setEndpointActivationState: function setEndpointActivationState(id, active) {
            var record = this._registry[id];
            if (record) {
                var now = moment().utc();
                record.active = active;
                record.status = undetermined;
                record.timestamp = now;
                record.since = now;
                logger.debug(&#x27;Endpoint &#x27; + id + &#x27; activation state set to: &#x27; + active);
                if (active) {
                    this._restartIfPassive();
                }
            } else {
                logger.warn(&#x27;Unable to set the activation state, endpoint \&#x27;&#x27; + id + &#x27;\&#x27; does not exist.&#x27;);
            }
        },

        /**
         * Enables/disables the notification on erroneous status for the endpoint with the specified id.
         *
         * @method notifyOnErroneousStatus
         * @param {String} id the endpoint id.
         * @param {Boolean} notify true or false to enable or disable the notification respectively.
         */
        notifyOnErroneousStatus: function notifyOnErroneousStatus(id, notify) {
            var record = this._registry[id];
            if (record) {
                record.notify = notify;
                logger.debug(&#x27;Endpoint \&#x27;&#x27; + id + &#x27;\&#x27; notification state set to: &#x27; + notify);
            } else {
                logger.warn(&#x27;Unable to set the notification state, endpoint \&#x27;&#x27; + id + &#x27;\&#x27; does not exist.&#x27;);
            }
        },

        /**
         * Returns the registered resolution strategies.
         *
         * @method getResolutionStrategies
         * @return {Array} the strategies.
         */
        getResolutionStrategies: function getResolutionStrategies() {
            return this.options.resolutionStrategies;
        },

        /**
         * Setup the Watcher.
         *
         * @private
         * @method _setup
         */
        _setup: function _setup() {
            logger.debug(&#x27;Setting up watcher engine...&#x27;);
            var _self = this;
            var options = _self.options, registry = _self._registry;

            var serverValErrors = validator.validateServer(options);
            if (_.isEmpty(serverValErrors)) {

                _self.server = httpServerFactory.create({
                    port: options.port,
                    host: options.host,
                    routesCallback: function routesCallback(app) {
                        var routes = require(&#x27;./routes/watcher-http&#x27;);
                        app.param(&#x27;id&#x27;, function (req, res, next, id) {
                            req.id = id;
                            next();
                        });
                        app.get(&#x27;/endpoint/:id&#x27;, routes.endpoint(_self));
                        app.post(&#x27;/endpoint/add&#x27;, routes.addEndpoint(_self));
                        app.post(&#x27;/endpoint/remove&#x27;, routes.removeEndpoint(_self));
                        app.post(&#x27;/endpoint/activation&#x27;, routes.endpointActivation(_self));
                        app.post(&#x27;/endpoint/notification&#x27;, routes.endpointNotification(_self));
                        app.get(&#x27;/endpoints&#x27;, routes.endpoints(_self));
                        app.get(&#x27;/resolution-strategies&#x27;, routes.resolutionStrategies(_self));

                        app.get(&#x27;/console&#x27;, function (req, res) {
                            res.render(&#x27;console&#x27;);
                        });

                        // put here the route extensions
                        _.each(options.routeExts, function (routeExt) {
                            app.use(routeExt.path, routeExt.route(registry));
                        });
                    }
                });

                // Retrieve stored endpoints
                var storedEnpoints = this._getStoredEndpoints();
                // Concat stored and configured endpoints
                var endpoints = options.endpoints.concat(storedEnpoints);
                // Register service endpoint
                _.each(endpoints, function (endpoint) {
                    try {
                        _self.addEndpoint(endpoint);
                    } catch (e) {
                        logger.error(&#x27;Endpoint \&#x27;&#x27; + endpoint.id + &#x27;\&#x27; registration failed: &#x27; + e.message);
                    }
                });
                logger.info(&#x27;Properties are successfully loaded: &#x27; + JSON.stringify(options));
            } else {
                logger.error(&#x27;validation errors:&#x27;);
                _.each(serverValErrors, function (error) {
                    logger.error(error);
                });
                _self.stop();
            }
            _self.emitter.emit(watcherConfigured);
            return _self;
        },

        /**
         * Starts the Watcher.
         *
         * @method start
         */
        start: _.once(function start() {
            var _self = this;
            _self._stopped = false;
            _self._setup();

            var port = _self.options.port,
                host = _self.options.host,
                interval = _self.options.interval;

            _self.server.start(function () {
                _self.emitter.emit(watcherReady);
                logger.info(&#x27;Watcher is up and running (host/port/interval): (&#x27; +
                host + &#x27;/&#x27; + port + &#x27;/&#x27; + interval + &#x27;)&#x27;);
                setTimeout(_.bind(_self._pollEndpoints, _self), 0).unref();
            });

            return _self;
        }),

        /**
         * Stops the Watcher.
         *
         * @method stop
         */
        stop: _.once(function stop() {
            logger.debug(&#x27;Shutting down Watcher app...&#x27;);
            this._stopped = true;
            this.server.stop();
            //process.kill(process.pid, &#x27;SIGHUP&#x27;);
        }),

        /**
         * Add listener specific events of the Watcher.
         *
         * @method addListener
         * @param {String} event the event.
         * @param {Object} listener the listener.
         */
        addListener: function addListener(event, listener) {
            this.emitter.on(event, listener);
        }

    }
);

/**
 * Watcher factory.
 * @class WatcherFactory
 * @static
 */
watcherFactory = {
    /**
     * Creates a Watcher instance.
     * @static
     * @method create
     * @param {Object} options the Watcher configuration.
     * Properties in _[]_ are optional. when not set, the default values are used - those in parentheses.
     * * Embedded http server configuration and service communication interval
     *  * [__host__] (&#x27;localhost&#x27;), the http server host name.
     *  * [__port__] (7777), the http server port.
     *  * [__interval__] (10000 ms), the service communication interval, at ms.
     *  * [__routeExts__], an array of user defined route extensions for building custom responses for the status requests.
     *  * [__resolutionStrategies__], an array of _unbound resolution strategy descriptors_.
     *  The descriptor is an object as follows:
     *  &#x60;&#x60;&#x60;
     *  {
     *      id: &lt;the resolution strategy id&gt;, (should be unique)
     *      desc: &lt;the resolution strategy description&gt;
     *      implementation: &lt;the implementation of resolution strategy&gt; (see at resolvers to see the interface)
     *  }
     *  &#x60;&#x60;&#x60;
     *  * [__nfOpts__], the notification options. Holds the information of the sender and the email addresses
     *  to receive email when erroneous service status occurs. The default sender is _admin@watcherjs.com_
     *  (if needed, configure your email account to not filter this sender as a spam). The object structure is:
     *  &#x60;&#x60;&#x60;
     *  {
     *      sender: &lt;the sender&gt;, // default value: admin@watcherjs.com
     *      recipients: [&lt;recipient1&gt;, &lt;recipient1&gt;, ...] // the array of recipients email
     *  }
     *  &#x60;&#x60;&#x60;
     *  * [__exportDir__] (_&lt;&#x60;project directory&#x60;&gt;/storage/_), the storage directory of dynamically created endpoints.
     * * Endpoint
     *  * __id__, the unique endpoint id.
     *  * __type__, the endpoint type.
     *  * [__host__] (localhost), the endpoint hostname, applied for __{{#crossLink &quot;SocketConnector&quot;}}{{/crossLink}}__.
     *  * [__port__] (9999), the endpoint port, applied for __{{#crossLink &quot;SocketConnector&quot;}}{{/crossLink}}__.
     *  * [__url__] (http://localhost:8080), the endpoint url, applied for __{{#crossLink &quot;HttpConnector&quot;}}{{/crossLink}}__.
     *  * [__timeout__](5000), the applied connector&#x27;s connection timeout.
     *  * [__resolutionStrategy__] (__{{#crossLink &quot;OnConnectionResolution&quot;}}{{/crossLink}}__) the applied resolution
     *  strategy, either as an implementation of a resolution strategy or as a reference id of an unbound strategy.
     *  * [__active__] (true), whether or not the endpoint should be activated (enables or suspends
     *  the communication between the respective connector and the endpoint).
     *  * [__notify__] (false), used to indicate whether or not to receive email notifications for
     *  erroneous service status.
     *
     * More details at __{{#crossLinkModule &quot;watcher&quot;}}{{/crossLinkModule}}__.
     *
     * @return {Watcher} the Watcher instance.
     */
    create: function create(options) {
        var _options = {
            port: 7777,
            host: &#x27;localhost&#x27;,
            interval: 10000,
            routeExts: [],
            resolutionStrategies: [],
            nfOpts: {},
            exportDir: __dirname + &#x27;/../storage&#x27;,
            endpoints: []
        };
        options = options || {};
        _.defaults(options, _options);
        options.nfOpts.sender = options.nfOpts.sender || &#x27;admin@watcherjs.com&#x27;;
        return watcher.create({
            options: options,
            emitter: new events.EventEmitter()
        });
    }
};

/**
 * Exported module object
 */
module.exports = {
    watcherFactory: watcherFactory
};
    </pre>
</div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
