<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>src/watcher.js - watcher.js</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="icon" href="../assets/favicon.ico">
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
                <h1><img src="../assets/css/logo.png" title="watcher.js" width="117" height="52"></h1>
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: 2.5.x</em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
                    <h2 class="off-left">APIs</h2>
                    <div id="api-tabview" class="tabview">
                        <ul class="tabs">
                            <li><a href="#api-classes">Classes</a></li>
                            <li><a href="#api-modules">Modules</a></li>
                        </ul>
                
                        <div id="api-tabview-filter">
                            <input type="search" id="api-filter" placeholder="Type to filter APIs">
                        </div>
                
                        <div id="api-tabview-panel">
                            <ul id="api-classes" class="apis classes">
                                <li><a href="../classes/AbstractConnector.html">AbstractConnector</a></li>
                                <li><a href="../classes/DBConnectionFactory.html">DBConnectionFactory</a></li>
                                <li><a href="../classes/Dictionary.html">Dictionary</a></li>
                                <li><a href="../classes/DictionaryFactory.html">DictionaryFactory</a></li>
                                <li><a href="../classes/EventDispatcher.html">EventDispatcher</a></li>
                                <li><a href="../classes/EventDispatcherFactory.html">EventDispatcherFactory</a></li>
                                <li><a href="../classes/HttpConnector.html">HttpConnector</a></li>
                                <li><a href="../classes/HttpConnectorFactory.html">HttpConnectorFactory</a></li>
                                <li><a href="../classes/Logger.html">Logger</a></li>
                                <li><a href="../classes/OnConnectionResolution.html">OnConnectionResolution</a></li>
                                <li><a href="../classes/OnConnectionResolutionFactory.html">OnConnectionResolutionFactory</a></li>
                                <li><a href="../classes/ResolutionStrategy.html">ResolutionStrategy</a></li>
                                <li><a href="../classes/ResolutionStrategyFactory.html">ResolutionStrategyFactory</a></li>
                                <li><a href="../classes/ResolverEvents.html">ResolverEvents</a></li>
                                <li><a href="../classes/ServiceStatus.html">ServiceStatus</a></li>
                                <li><a href="../classes/SocketConnector.html">SocketConnector</a></li>
                                <li><a href="../classes/SocketConnectorFactory.html">SocketConnectorFactory</a></li>
                                <li><a href="../classes/StatusResolver.html">StatusResolver</a></li>
                                <li><a href="../classes/StatusResolverFactory.html">StatusResolverFactory</a></li>
                                <li><a href="../classes/TransactionalExecutor.html">TransactionalExecutor</a></li>
                                <li><a href="../classes/Validator.html">Validator</a></li>
                                <li><a href="../classes/Watcher.html">Watcher</a></li>
                                <li><a href="../classes/WatcherEvents.html">WatcherEvents</a></li>
                                <li><a href="../classes/WatcherFactory.html">WatcherFactory</a></li>
                                <li><a href="../classes/WatcherHttp.html">WatcherHttp</a></li>
                            </ul>
                
                            <ul id="api-modules" class="apis modules">
                                <li><a href="../modules/connectors.html">connectors</a></li>
                                <li><a href="../modules/constants.html">constants</a></li>
                                <li><a href="../modules/database.html">database</a></li>
                                <li><a href="../modules/httpServer.html">httpServer</a></li>
                                <li><a href="../modules/logger.html">logger</a></li>
                                <li><a href="../modules/resolvers.html">resolvers</a></li>
                                <li><a href="../modules/utils.html">utils</a></li>
                                <li><a href="../modules/validator.html">validator</a></li>
                                <li><a href="../modules/watcher.html">watcher</a></li>
                                <li><a href="../modules/watcher-http.html">watcher-http</a></li>
                            </ul>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
                    Show:
                    <label for="api-show-inherited">
                        <input type="checkbox" id="api-show-inherited" checked>
                        Inherited
                    </label>
            
                    <label for="api-show-protected">
                        <input type="checkbox" id="api-show-protected">
                        Protected
                    </label>
            
                    <label for="api-show-private">
                        <input type="checkbox" id="api-show-private">
                        Private
                    </label>
                    <label for="api-show-deprecated">
                        <input type="checkbox" id="api-show-deprecated">
                        Deprecated
                    </label>
            
                </div>
            
            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
<h1 class="file-heading">File: src/watcher.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
/**
 * Created by jpsoroulas.
 */
/**
 * ###Overview
 * This is the main application module. It provides the factory method for creating an application,
 * the so called __watcher.js__, that can be used to monitor service status.
 * The application architecture is very simple. At regular intervals (_service communication interval_),
 * service specific defined messages, either as http requests or as raw data to sockets (depending on the
 * communication type of the service endpoint), are send to the monitored services, or to be more precise are send
 * to the service endpoints (or simply endpoints), to find out their status (the _service_ and  endpoint_ notation
 * is used interchangeably, but there is a conceptual difference between them which will be discussed shortly).
 * On the service status resolution, the status is stored internally and is made available either programmatically or
 * via http requests (aka the _status requests_).
 * Actually, __the entire application API is also exposed as REST API__, which, on top of this, a simple but handy
 * __web gui__ is implemented. For the REST API implementation the [express](http://expressjs.com) web framework is used.
 * The REST interface description with references to the respective application API can be found at
 * __{{#crossLinkModule &quot;watcher-http&quot;}}{{/crossLinkModule}}__.
 * Moreover, a [socket.io](http://socket.io/) client can be used for real time event notification from the system. At the moment
 * a client could be notified when the endpoints status has been updated. More information and examples can be found at
 * __{{#crossLink &quot;WatcherEvents&quot;}}{{/crossLink}}__ and the examples source directory.
 *
 *
 * ###Configuration
 * The application configuration requires two kinds of data, as shown below. The one that refers to the
 * express framework that implements the application http interface, and the other that refers to the service
 * endpoints. Note that properties in _[]_ are optional. when not set, the default values are used - those in parentheses.
 *
 *
 * * Embedded http server configuration and service communication interval
 *  * [__host__] (&#x27;localhost&#x27;), the http server host name.
 *  * [__port__] (7777), the http server port.
 *  * [__interval__] (10000 ms), the regular interval, at ms, that the application attempts to establish
 *  communication with the services to resolve their status (_service communication interval_).
 *  * [__routeExts__], an array of user defined route extensions for building custom responses for the status requests.
 *  A route extension should be a function that accepts the __{{#crossLink &quot;Watcher/_registry:property&quot;}}{{/crossLink}}__
 *  as parameter and return a function that conforms to [express route](http://expressjs.com/guide/routing.html) conventions
 *  (a function with parameters: _req_, _res_, _next_, as shown at the examples)
 *  * [__resolutionStrategies__], an array of objects (aka unbound resolution strategy descriptor), each of them holds the
 *  information for an _unbound resolution strategy_ (__{{#crossLinkModule &quot;resolvers&quot;}}{{/crossLinkModule}}__) to be registered
 *  at the system. These strategies are not bound to any endpoint, but they can be associated with them by setting the
 *  respective strategy id at the endpoint&#x27;s _resolutionStrategy_ configuration property (see at endpoint configuration below).
 *  The descriptor is an object as follows:
 *  &#x60;&#x60;&#x60;
 *  {
 *      id: &lt;the resolution strategy id&gt;, (should be unique)
 *      desc: &lt;the resolution strategy description&gt;
 *      implementation: &lt;the implementation of resolution strategy&gt; (see at resolvers to see the interface)
 *  }
 *  &#x60;&#x60;&#x60;
 *  * [__nfOpts__], the notification options. Holds the information of the sender and the email addresses
 *  to receive email when erroneous service status occurs. The default sender is _admin@watcherjs.com_
 *  (if needed, configure your email account to not filter this sender as a spam). The object structure is:
 *  &#x60;&#x60;&#x60;
 *  {
 *      sender: &lt;the sender&gt;, // default value: admin@watcherjs.com
 *      recipients: [&lt;recipient1&gt;, &lt;recipient1&gt;, ...] // the array of recipients email
 *  }
 *  &#x60;&#x60;&#x60;
 *  * [__exportDir__] (_&lt;&#x60;project directory&#x60;&gt;/storage/_), the storage directory of dynamically created endpoints.
 *  * [__dbConnectionURL__] (_&#x27;mongodb://localhost:27017/&#x27;_), the connection url of history persistent storage
 *  (currently, the mongoDB is used)
 *
 *
 * * Endpoint
 *  * __id__, the unique endpoint/service id. This _id_ is used for the service identification when a service request is made.
 *  * __type__, the endpoint type, the type determines whether the message
 *  exchange is performed via http requests or directly with the socket. It actually dictates the underline
 *  connector used for the specific service (see also at __{{#crossLinkModule &quot;connectors&quot;}}{{/crossLinkModule}}__).
 *  The permitted values are: __&#x27;socket&#x27;__ and __&#x27;http&#x27;__ for __{{#crossLink &quot;SocketConnector&quot;}}{{/crossLink}}__
 *  and __{{#crossLink &quot;HttpConnector&quot;}}{{/crossLink}}__ respectively.
 *  * [__desc__] (__id__), the endpoint description.
 *  * [__host__] (localhost), the endpoint hostname when a __{{#crossLink &quot;SocketConnector&quot;}}{{/crossLink}}__ is used.
 *  * [__port__] (9999), the endpoint port when a __{{#crossLink &quot;SocketConnector&quot;}}{{/crossLink}}__ is used.
 *  * [__url__] (http://localhost:8080), the endpoint url when __{{#crossLink &quot;HttpConnector&quot;}}{{/crossLink}}__ is used.
 *  * [__timeout__] (5000), the applied connector&#x27;s connection timeout (see also at
 *  __{{#crossLink &quot;SocketConnectorFactory/create:method&quot;}}{{/crossLink}}__ and
 *  __{{#crossLink &quot;HttpConnectorFactory/create:method&quot;}}{{/crossLink}}__).
 *  * [__resolutionStrategy__] (__{{#crossLink &quot;OnConnectionResolution&quot;}}{{/crossLink}}__) the applied resolution strategy.
 *  This property can hold either an implementation of a resolution strategy or the id of the an unbound strategy.
 *  * [__active__] (true), used to indicate whether or not the endpoint should be activated
 *  (enables or suspends the communication between the respective connector and the endpoint).
 *  * [__notify__] (false), used to indicate whether or not to receive email notifications for erroneous service status.
 *
 *
 * The _endpoint_ notation is used to emphases that the _service_ can be proxied by another service (_the proxy_) which
 * is that determines the status of the proxied service. In this case, the endpoint belongs to the proxy and not to the
 * monitored service.
 *
 *
 * ###Exported objects
 * * __{{#crossLink &quot;WatcherFactory&quot;}}{{/crossLink}}__
 *
 *
 * ###API Usage samples
 * __Service with route extension and resolution strategy registration__
 *    &#x60;&#x60;&#x60;javascript
 * // Here is the configuration of three endpoints. Two of them are accessed via sockets and refer to the services
 * // &#x27;service-1&#x27; and &#x27;service-2&#x27; hosted at &#x27;11.222.333.444&#x27; and &#x27;11.222.333.555&#x27; respectively, whereas the other is
 * // accessed via http and refers to the service &#x27;service-3&#x27; that is also hosted at &#x27;11.222.333.555&#x27; (note that we use
 * // the notation _service_ since the _endpoint_ and the _service_ is the same component).
 * // Fix the module paths
 * var watcher = require(&#x27;watcher&#x27;);
 * var constants = require(&#x27;constants&#x27;);
 * var resolvers = require(&#x27;resolvers&#x27;);
 *
 * var down = constants.serviceStatus.down;
 * var watcherFactory = watcher.watcherFactory;
 * var onConnectionResolutionFactory = resolvers.onConnectionResolutionFactory;
 *
 * var alwaysDownStrategy = {
 *       reset: function reset() {},
 *       resolveOnConnection: function resolveOnConnection(connection) {
 *          //mark as down only for demonstration purposes
 *           return down;
 *       },
 *       resolveOnConversation: function resolveOnConversation(connection, chunk) {},
 *       resolveNow: function resolveNow(connection) {}
 *   };
 *
 * var options = {
 *     port: 7777,
 *     interval: 15000,
 *    routeExts: [{
 *          path: &#x27;/custom-route&#x27;,
 *          route: function service(registry) {
 *              return function (req, res, next) {
 *                  var id = req.query.id;
 *                  var endpoint = registry[id];
 *                  if (endpoint) {
 *                      res.send(&#x27;Service status: &#x27; + endpoint.status);
 *                  } else {
 *                      res.send(&#x27;Unknown service: &#x27; + id);
 *                  }
 *              };
 *          }
 *      }],
 *     resolutionStrategies: [
 *           {// Actually the default implementation, added for demonstration purposes
 *               id: &#x27;on-connection&#x27;,
 *               desc: &#x27;resolution on connection&#x27;,
 *               implementation: onConnectionResolutionFactory.create()
 *           },
 *           {
 *               id: &#x27;always-down&#x27;,
 *               desc: &#x27;always down&#x27;,
 *               implementation: alwaysDownStrategy
 *           }
 *       ],
 *     nfOpts: {
 *          recipients: [&#x27;foo@foo.com&#x27;]
 *      },
 *     endpoints: [
 *          {
 *              id: &#x27;service-1&#x27;,
 *              desc: &#x27;service 1&#x27;,
 *              type: &#x27;socket&#x27;,
 *              host: &#x27;11.222.333.444&#x27;,
 *              port: 1234,
 *              // Apply an implementation of resolution strategy
 *              resolutionStrategy: alwaysDownStrategy,
 *              active: true,
 *              notify: true
 *          },
 *          {
 *              id: &#x27;service-2&#x27;,
 *              desc: &#x27;service 2&#x27;,
 *              type: &#x27;socket&#x27;,
 *              host: &#x27;11.222.333.555&#x27;,
 *              port: 1234,
 *              // Apply the unbound resolution strategy with id &#x27;on-connection&#x27;
 *              resolutionStrategy: &#x27;on-connection&#x27;,
 *              active: true,
 *              notify: true
 *          },
 *          {
 *              id: &#x27;service-3&#x27;,
 *              desc: &#x27;service 3&#x27;,
 *              type: &#x27;http&#x27;,
 *              timeout: 3000,
 *              // The query string could be anything
 *              url: &#x27;http://11.222.333.555:3333/?get-status&#x27;,
 *              active: true,
 *              notify: true
 *          }
 *      ]
 *  };
 * watcherFactory.create(options).start();
 *
 * After starting the watcher the following status requests could be made in order to
 * retrieve the status for the services with id &#x27;service-1&#x27;, &#x27;service-2&#x27; and &#x27;service-3&#x27; respectively
 * http://localhost:7777/endpoints/service-1
 * http://localhost:7777/endpoints/service-2
 * http://localhost:7777/endpoints/service-3
 * Whereas the request http://localhost:7777/custom-route?id=service-1
 * is the user defined route which returns: &#x27;Service status: &lt;status&gt;&#x27; where status
 * the status of the &#x27;service-1&#x27;.
 *    &#x60;&#x60;&#x60;
 * __Proxied services__
 *    &#x60;&#x60;&#x60;javascript
 * // Proxied services
 * // Here is the case where a proxy controls the status of two service (e.g. _proxied-service-1_
 * // and _proxied-service-2_). The proxy is hosted at &#x27;11.222.333.444&#x27; and can be accessed via http.
 * // Two http endpoints at the proxy are created, the &#x27;endpoint-1&#x27; and &#x27;endpoint-2&#x27; each one of them
 * // is connected with the respective monitored proxied services (note that we use the notation _endpoint_ since
 * // the _endpoint_ is not the monitored _service_).
 *
 * // Fix the module paths
 * var watcherFactory = require(&#x27;watcher&#x27;).watcherFactory;
 * var options = {
 *     port: 7777,
 *     interval: 15000,
 *     endpoints: [
 *          {
 *              id: &#x27;endpoint-1&#x27;,
 *              type: &#x27;http&#x27;,
 *              timeout: 3000,
 *              // request to the proxied service &#x27;proxied-service-1&#x27;, the query string could be anything
 *              url: &#x27;http://11.222.333.444:3333/?get-status-for=proxied-service-1&#x27;
 *          },
 *          {
 *              id: &#x27;endpoint-2&#x27;,
 *              type: &#x27;http&#x27;,
 *              timeout: 3000,
 *              // request to the proxied service &#x27;proxied-service-2&#x27;, the query string could be anything
 *              url: &#x27;http://11.222.333.444:3333/?get-status-for=proxied-service-2&#x27;
 *          }
 *      ]
 *  };
 * watcherFactory.create(options).start();
 *
 * After starting the watcher the following status requests could be made in order to
 * retrieve the status for &#x27;proxied-service-1&#x27; and &#x27;proxied-service-2&#x27; respectively
 * http://localhost:7777/endpoints/endpoint-1
 * http://localhost:7777/endpoints/endpoint-2
 *    &#x60;&#x60;&#x60;
 *
 * __Add and remove endpoints dynamically__
 *    &#x60;&#x60;&#x60;javascript
 * // Here is an example for dynamically adding and removing endpoints
 *
 * // Fix the module paths
 * var watcherFactory = require(&#x27;watcher&#x27;).watcherFactory;
 * var options = {
 *     port: 7777,
 *     interval: 15000,
 *     endpoints: [
 *          {
 *              id: &#x27;service-1&#x27;,
 *              type: &#x27;socket&#x27;,
 *              host: &#x27;11.222.333.444&#x27;,
 *              port: 1234
 *          }
 *      ]
 *  };
 * var watcher = watcherFactory.create(options).start();
 *
 * // Add the endpoint &#x27;service-2&#x27;
 * setTimeout(function() {
 *        watcher.addEndpoint({
 *          id: &#x27;service-2&#x27;,
 *          type: &#x27;http&#x27;,
 *          timeout: 3000,
 *          url: &#x27;http://11.222.333.555:3333/?get-status&#x27;
 *      }, false, function() {
 *            if (!_.isEmpty(errors)) {
 *               throw new Error(&#x27;validation error...&#x27;);
 *           }
 *      });
 * }, 6000);
 *
 * // Deactivate the endpoint &#x27;service-2&#x27;
 * setTimeout(function () {
 *      watcher.setEndpointActivationState(&#x27;service-2&#x27;, false);
 * }, 12000);
 *
 * // Activate the endpoint &#x27;service-2&#x27;
 * setTimeout(function () {
 *        watcher.setEndpointActivationState(&#x27;service-2&#x27;, true);
 *   }, 30000);
 *
 * // Remove the endpoint &#x27;service-2&#x27;
 * setTimeout(function() {
 *       watcher.removeEndpoint(&#x27;service-2&#x27;);
 * }, 60000);
 *
 * // Shutdown the application
 * setTimeout(function () {
 *      watcher.stop();
 * }, 120000);
 *
 *    &#x60;&#x60;&#x60;
 *
 * @module watcher
 */
&#x27;use strict&#x27;;
var fs = require(&#x27;fs-extra&#x27;);
var events = require(&#x27;events&#x27;);
var path = require(&#x27;path&#x27;);
var stampit = require(&#x27;stampit&#x27;);
var _ = require(&#x27;underscore&#x27;);
var async = require(&#x27;async&#x27;);
var asyncTimeout = require(&#x27;async-timeout&#x27;);
var moment = require(&#x27;moment&#x27;);
var nodemailer = require(&#x27;nodemailer&#x27;);
var directTransport = require(&#x27;nodemailer-direct-transport&#x27;);
//var http = require(&#x27;http&#x27;);
//var query = require(&#x27;connect-query&#x27;);
//var fs = require(&#x27;fs&#x27;);
//var connect = require(&#x27;connect&#x27;);
//var s = require(&#x27;underscore.string&#x27;);

var logger = require(&#x27;./logger&#x27;);
var validator = require(&#x27;./validator&#x27;);
var constants = require(&#x27;./constants&#x27;);
var connectors = require(&#x27;./connectors&#x27;);
var httpServerFactory = require(&#x27;./http-server&#x27;);
var dbConnFactory = require(&#x27;./database&#x27;);
//var utils = require(&#x27;./utils&#x27;);

var up = constants.serviceStatus.up;
var socketConnectorFactory = connectors.socketConnectorFactory;
var httpConnectorFactory = connectors.httpConnectorFactory;
var undetermined = constants.serviceStatus.undetermined;
var wjsConfigured = constants.watcherEvents.wjsConfigured;
var wjsReady = constants.watcherEvents.wjsReady;
var endpointsStatusResolved = constants.watcherEvents.endpointsStatusResolved;
var wjsConnected = constants.watcherEvents.wjsConnected;
var wjsEndpointsUpdated = constants.watcherEvents.wjsEndpointsUpdated;
var socketConnectorType = constants.connectorType.socket;
var httpConnectorType = constants.connectorType.http;

var watcher, watcherFactory;

function createConnector(endpoint) {
    var connector, type = endpoint.type;
    switch (type) {
        case socketConnectorType:
            connector = socketConnectorFactory.create(endpoint);
            break;
        case httpConnectorType:
            connector = httpConnectorFactory.create(endpoint);
            break;
        default:
            throw new Error(&#x27;Can not create connector type: &#x27; + type);
    }
    return connector;
}

/**
 * The application that can be used to monitor your services status.
 * An application overview and detailed configuration instructions and examples can be found at
 * __{{#crossLinkModule &quot;watcher&quot;}}{{/crossLinkModule}}__
 *
 * @class Watcher
 */
watcher = stampit().state({
    options: void 0,
    emitter: void 0
}).enclose(function () {
    // listen for terminal signal e.g. kill
    process.on(&#x27;SIGTERM&#x27;, _.bind(this.stop, this));

    // listen for interrupt signal e.g. Ctrl-C
    process.on(&#x27;SIGINT&#x27;, _.bind(this.stop, this));
    /**
     * Holds the registered endpoints.
     *
     * @private
     * @property _registry
     * @type Object
     */
    this._registry = {};

    this._transporter = nodemailer.createTransport(directTransport({}));

    this._passive = false;
}).methods({
        /**
         * Registers an endpoint.
         *
         * @private
         * @method _registerEndpoint
         * @param {Object} config the endpoint configuration.
         * @return the endpoint.
         */
        _registerEndpoint: function _registerEndpoint(config) {
            var now = moment.utc();
            var _endpoint = {
                status: undetermined,
                timestamp: now,
                since: now,
                processed: false,
                active: true,
                notify: false
            };
            config = _.clone(config);
            var connector = createConnector(config);
            var endpoint = _.omit(_.defaults(config, _endpoint), &#x27;resolutionStrategy&#x27;);
            var id = endpoint.id;
            endpoint.desc = endpoint.desc || id;
            endpoint.connector = connector;
            // Register status resolved listener
            var listener = _.bind(_.partial(this._onStatusResolve, endpoint), this);
            connector.addStatusResolvedListener(listener);

            this._registry[id] = endpoint;
            logger.debug(&#x27;New endpoint registered: &#x27; + id);
            return endpoint;
        },

        /**
         * Sends notification email if erroneous service status occurs.
         *
         * @private
         * @method _notify
         */
        _notify: function _notify() {
            var toBeNotified;
            var sender = this.options.nfOpts.sender;
            var recipients = this.options.nfOpts.recipients;
            if (!_.isEmpty(recipients)) {
                toBeNotified = _.filter(this._registry, function (endpoint) {
                    var status = endpoint.status;
                    if (endpoint.active &amp;&amp; up !== status &amp;&amp; undetermined !== status) {
                        if (endpoint.notify &amp;&amp; (status !== endpoint.previousStatus || !endpoint.notified)) {
                            return true;
                        }
                    } else {
                        endpoint.notified = false;
                    }
                    return false;
                });

                if (!_.isEmpty(toBeNotified)) {
                    var msg = [];
                    _.each(toBeNotified, function (endpoint) {
                        msg.push(&#x27;Endpoint, \&#x27;&#x27; + endpoint.id + &#x27;\&#x27;, status: &#x27; + endpoint.status +
                        &#x27;, timestamp: &#x27; + endpoint.timestamp.format(&#x27;MMMM Do YYYY, h:mm:ss&#x27;));
                    });
                    msg = msg.join(&#x27;&#x27;);
                    this._transporter.sendMail({
                        from: sender,
                        to: recipients.join(&#x27;,&#x27;),
                        subject: &#x27;Notification&#x27;,
                        text: msg
                    }, function (error, response) {
                        if (error) {
                            logger.warn(&#x27;Notification message failed: &#x27; + error);
                        } else {
                            logger.info(&#x27;Notification message send: &#x27; + msg);
                            _.each(toBeNotified, function (endpoint) {
                                endpoint.notified = true;
                            });
                        }
                    });
                }

            }
        },

        _onStatusResolve: function _onStatusResolve(endpoint, status) {
            if (!this._stopped) {
                var now = moment.utc();
                endpoint.timestamp = now;
                if (status !== endpoint.status) {
                    endpoint.since = now;
                    //store to database
                    this._storeStatusToHistory(endpoint, status);
                }
                endpoint.previousStatus = endpoint.status;
                endpoint.status = status;
                endpoint.processed = true;
                logger.debug(&#x27;Update registry, id/status: &#x27; + endpoint.id + &#x27;/&#x27; + status);
                if (_.every(this._registry,
                        function (endpoint) {
                            return (endpoint.processed === true);
                        })) {
                    this._notify();
                    this.emitter.emit(endpointsStatusResolved);
                    setTimeout(_.bind(this._pollEndpoints, this), this.options.interval).unref();
                }
            }
        },

        _storeStatusToHistory: function (endpoint, status) {
            var now = moment.utc();
            this.db.history.insert({
                endpointId: endpoint.id,
                timestamp: now.valueOf(),
                statusTransition: {
                    from: endpoint.status,
                    to: status
                }
            }, function (err, docs) {
                if (err) {
                    logger.warn(&#x27;Unable to update the persistent state of \&#x27;&#x27; + endpoint.id + &#x27;\&#x27;, &#x27; + err);
                }
            });
        },

        _pollEndpoints: function _pollEndpoints() {
            var _self = this;
            if (!_self._stopped) {
                var registry = _self._registry;
                _.each(registry, function (endpoint) {
                    endpoint.processed = false;
                });
                var passive = this._passive = _.every(registry, function (endpoint) {
                    return !(endpoint.active);
                });
                if (passive) {
                    logger.debug(&#x27;No active endpoints, system passivated.&#x27;);
                } else {
                    logger.debug(&#x27;Poll for services status...&#x27;);
                    _.each(registry, function (endpoint) {
                        if (endpoint.active) {
                            endpoint.connector.start.call(endpoint.connector);
                        } else {
                            endpoint.processed = true;
                        }
                    });
                }
            }
        },

        _writeEndpointConfigToFile: function _writeEndpointConfigToFile(fileName, config, callback) {
            fs.outputJson(fileName, config, function (err) {
                if (err) {
                    logger.error(&#x27;Endpoint storage \&#x27;&#x27; + config.id + &#x27;\&#x27; failed: &#x27; + err);
                    err = &#x27;Update endpoint configuration at storage failed (&#x27; + err.message + &#x27;)&#x27;;
                }
                callback(err, config);
            });
        },

        /**
         * Activates the system again if it is passivated.
         *
         * @private
         * @method _restartIfPassive
         */
        _restartIfPassive: function _restartIfPassive() {
            if (true === this._passive) {
                logger.debug(&#x27;Active endpoint found, system activated.&#x27;);
                setTimeout(_.bind(this._pollEndpoints, this), 0).unref();
            }
        },

        /**
         * Stores endpoint at the persistence storage
         * (the filesystem is used for easy modification).
         *
         * @private
         * @method _persistEndpointConfig
         * @param {Object} config the endpoint configuration.
         * @param {Function} callback callback function to async write operation.
         * @throws {Error} An error when the operation can not be performed (e.g. no write permissions).
         */
        _persistEndpointConfig: function _persistEndpointConfig(config, callback) {
            var fileName = path.join(this.options.exportDir, config.id + &#x27;.json&#x27;);
            config = _.clone(config);
            var strategy = config.resolutionStrategy;
            if (strategy) {
                config.resolutionStrategy = strategy.id;
            }
            this._writeEndpointConfigToFile(fileName, config, callback);
        },

        /**
         * Deletes the endpoint of the specified id from the persistence storage
         * (the filesystem is used for easy modification).
         *
         * @private
         * @method _deleteEndpoint
         * @param {String} id the endpoint id.
         * @param {Function} callback the callback(err) of the async process.
         */
        _deleteEndpoint: function _deleteEndpoint(id, callback) {
            var fileName = path.join(this.options.exportDir, id + &#x27;.json&#x27;);
            fs.exists(fileName, function (exists) {
                if (exists) {
                    fs.remove(fileName, function (err) {
                        if (!err) {
                            logger.info(&#x27;Endpoint \&#x27;&#x27; + id + &#x27;\&#x27; removed from storage: &#x27; + fileName);
                        }
                        callback(err);
                    });
                } else {
                    logger.debug(&#x27;Endpoint \&#x27;&#x27; + id + &#x27;\&#x27; is not persisted at local store.&#x27;);
                    callback(null);
                }
            });
        },

        /**
         * Updates the endpoint of the specified id from the persistence storage
         * (the filesystem is used for easy modification).
         *
         * @private
         * @method _updateEndpointConfig
         * @param {String} id the endpoint id.
         * @param {Object} properties updated properties.
         * @param {Function} callback the callback(err, properties) of the async process.
         */
        _updateEndpointConfig: function _updateEndpointConfig(id, properties, callback) {
            var _self = this;
            var fileName = path.join(this.options.exportDir, id + &#x27;.json&#x27;);
            fs.exists(fileName, function (exists) {
                if (exists) {
                    fs.readJson(fileName, function (err, config) {
                        if (!err) {
                            _.extend(config, properties);
                            _self._writeEndpointConfigToFile(fileName, config, callback);
                        } else {
                            logger.warn(&#x27;Unable to update endpoint persistence state, invalid json file: &#x27; + fileName);
                            callback(err, properties);
                        }
                    });
                } else {
                    logger.debug(&#x27;Endpoint \&#x27;&#x27; + id + &#x27;\&#x27; not found at local store, not permanent changes.&#x27;);
                    callback(null, properties);
                }
            });
        },

        /**
         * Stores endpoint info at persistence storage (at the filesystem for easy modification).
         *
         * @private
         * @method _getStoredEndpoints
         * @return {Array} the persistent endpoints.
         */
        _getStoredEndpoints: function _getStoredEndpoints() {
            var storage = this.options.exportDir;
            fs.ensureDirSync(storage);
            logger.debug(&#x27;Ensuring existence of endpoints storage directory: &#x27; + storage);
            var storedEnpoints = [];
            fs.readdirSync(storage).forEach(function (file) {
                var entry = path.join(storage, file);
                var stats = fs.statSync(entry);
                if (!stats.isDirectory()) {
                    var endpoint = fs.readJsonSync(entry, {throws: false});
                    if (!_.isNull(endpoint)) {
                        storedEnpoints.push(endpoint);
                        logger.info(&#x27;Get endpoint from storage: &#x27; + entry);
                    } else {
                        logger.warn(&#x27;Unable to construct endpoint from storage, invalid json file: &#x27; + entry);
                    }
                }
            });
            return storedEnpoints;
        },

        /**
         * Returns the endpoint with the specified id.
         *
         * @method getEndpoint
         * @param {String} id the endpoint id.
         * @return {Object} the endpoint.
         */
        getEndpoint: function getEndpoint(id) {
            return this._registry[id];
        },

        /**
         * Returns the endpoints.
         *
         * @method getEndpoints
         * @return {Array} the endpoints.
         */
        getEndpoints: function getEndpoints() {
            return _.values(this._registry);
        },

        /**
         * Adds an endpoint with the specified configuration.
         * For the configuration see at {{#crossLinkModule &quot;watcher&quot;}}{{/crossLinkModule}}
         *
         * @method addEndpoint
         * @param {Object} config the endpoint configuration (see at
         * __{{#crossLink &quot;WatcherFactory/create:method&quot;}}{{/crossLink}}__).
         * @param {Boolean} store used to indicate whether or not to store the endpoint.
         * @param {Function} callback the callback(err, endpoint) of the async process.
         */
        addEndpoint: function addEndpoint(config, store, callback) {
            callback = callback || _.noop;
            var endpoint, registry = this._registry;
            var errors = validator.validateEndpointConfig(
                config, _.keys(registry), this.options.resolutionStrategies);
            if (_.isEmpty(errors)) {
                endpoint = this._registerEndpoint(config);
                if (endpoint.active) {
                    this._restartIfPassive();
                }
                if (store) {
                    this._persistEndpointConfig(config, function (err) {
                        if (err) {
                            err = {message: err};
                        }
                        callback(err, endpoint);
                    });
                } else {
                    callback(null, endpoint);
                }
            } else {
                callback({
                    message: &#x27;validation errors&#x27;,
                    errors: errors
                }, config);
            }
        },

        /**
         * Removes the endpoint with the specified id.
         *
         * @method removeEndpoint
         * @param {String} id the endpoint id.
         * @param {Function} callback the callback(err, id) of the async process.
         */
        removeEndpoint: function removeEndpoint(id, callback) {
            callback = callback || _.noop;
            var endpoint = this.getEndpoint(id);
            if (endpoint) {
                delete this._registry[id];
                this._deleteEndpoint(id, function (err) {
                    if (err) {
                        err = {message: err};
                    }
                    callback(err, id);
                });
            }
            logger.debug(&#x27;Endpoint \&#x27;&#x27; + id + &#x27;\&#x27; has been removed!&#x27;);
            return endpoint;
        },

        /**
         * Activate/Deactivates the endpoint with the specified id.
         *
         * @method setEndpointActivationState
         * @param {String} id the endpoint id.
         * @param {Boolean} active true or false to activate or deactivate the specific endpoint respectively.
         * @return {Object} the endpoint or undefined if the endpoint does not exist.
         * @param {Function} callback the callback(err, endpoint) of the async process.
         */
        setEndpointActivationState: function setEndpointActivationState(id, active, callback) {
            callback = callback || _.noop;
            var endpoint = this._registry[id];
            if (endpoint) {
                var now = moment().utc();
                if (undetermined !== endpoint.status) {
                    this._storeStatusToHistory(endpoint, undetermined);
                }
                endpoint.active = active;
                endpoint.status = undetermined;
                endpoint.timestamp = now;
                endpoint.since = now;
                logger.debug(&#x27;Endpoint &#x27; + id + &#x27; activation state set to: &#x27; + active);
                if (active) {
                    this._restartIfPassive();
                }
                this._updateEndpointConfig(id, {active: active}, function (err, config) {
                    if (err) {
                        err = {message: err};
                    }
                    callback(err, endpoint);
                });
            } else {
                logger.warn(&#x27;Unable to set the activation state, endpoint \&#x27;&#x27; + id + &#x27;\&#x27; does not exist.&#x27;);
            }
            return endpoint;
        },

        /**
         * Enables/disables the notification on erroneous status for the endpoint with the specified id.
         *
         * @method notifyOnErroneousStatus
         * @param {String} id the endpoint id.
         * @param {Boolean} notify true or false to enable or disable the notification respectively.
         * @param {Function} callback the callback(err, endpoint) of the async process.
         */
        notifyOnErroneousStatus: function notifyOnErroneousStatus(id, notify, callback) {
            callback = callback || _.noop;
            var endpoint = this._registry[id];
            if (endpoint) {
                endpoint.notify = notify;
                logger.debug(&#x27;Endpoint \&#x27;&#x27; + id + &#x27;\&#x27; notification state set to: &#x27; + notify);
                this._updateEndpointConfig(id, {notify: notify}, function (err, config) {
                    if (err) {
                        err = {message: err};
                    }
                    callback(err, endpoint);
                });
            } else {
                logger.warn(&#x27;Unable to set the notification state, endpoint \&#x27;&#x27; + id + &#x27;\&#x27; does not exist.&#x27;);
            }
            return endpoint;
        },

        /**
         * Returns the registered resolution strategies.
         *
         * @method getResolutionStrategies
         * @return {Array} the strategies.
         */
        getResolutionStrategies: function getResolutionStrategies() {
            return this.options.resolutionStrategies;
        },

        /**
         * Returns the endpoint/s history status.
         *
         * @method getHistory
         * @param {Object} qOpts the query options.
         * @param {Function} callback the callback(err, recs) of the async process.
         * @example __Query options details__.
         * &#x60;&#x60;&#x60;
         * //Specify the &quot;endpointId&quot; to return the history of the specific endpoint,
         * //otherwise the history of all endpoints is returned
         * //Specify both &#x27;from&#x27; and &#x27;to&#x27; properties to return the history status for
         * //the specific time period, otherwise the complete history is returned.
         *
         * {
         *     endpointId:  &lt;endpoint id&gt;
         *     from:        &lt;from time&gt;     //defined in mills
         *     to:          &lt;to time&gt;       //defined in mills
         * }
         * &#x60;&#x60;&#x60;
         */
        getHistory: function getHistory(qOpts, callback) {
            var query = {};
            var endpointId = qOpts.endpointId;
            var from = qOpts.from;
            var to = qOpts.to;
            if (from &amp;&amp; to) {
                query.timestamp = {$gte: parseFloat(from), $lte: parseFloat(to)};
            }
            if (endpointId) {
                query.endpointId = endpointId;
            }
            this.db.history.find({$query: query, $orderby: {timestamp: 1}}, function (err, recs) {
                if (err) {
                    logger.error(&#x27;Unable to get history, err: &#x27; + err + &#x27;, query: &#x27; + query);
                }
                callback(err, recs);
            });
        },

        /**
         * Setup the Watcher.
         *
         * @private
         * @method _setup
         */
        _setup: function _setup() {
            logger.debug(&#x27;Setting up watcher engine...&#x27;);
            var _self = this;
            var options = _self.options, registry = _self._registry;

            var serverValErrors = validator.validateServerConfig(options);
            if (_.isEmpty(serverValErrors)) {

                _self.server = httpServerFactory.create({
                    port: options.port,
                    host: options.host,
                    routesCallback: function routesCallback(app) {
                        var routes = require(&#x27;./routes/watcher-http&#x27;);
                        app.param(&#x27;id&#x27;, function (req, res, next, id) {
                            req.id = id;
                            next();
                        });
                        app.get(&#x27;/endpoints&#x27;, routes.endpoints(_self));
                        app.get(&#x27;/endpoints/:id&#x27;, routes.endpoint(_self));
                        app.post(&#x27;/endpoints/:id&#x27;, routes.addEndpoint(_self));
                        app.delete(&#x27;/endpoints/:id&#x27;, routes.removeEndpoint(_self));
                        app.post(&#x27;/endpoints/:id/activate&#x27;, routes.endpointActivate(_self));
                        app.delete(&#x27;/endpoints/:id/activate&#x27;, routes.endpointDeactivate(_self));
                        app.post(&#x27;/endpoints/:id/notify&#x27;, routes.endpointEnableNotification(_self));
                        app.delete(&#x27;/endpoints/:id/notify&#x27;, routes.endpointDisableNotification(_self));
                        app.get(&#x27;/resolution-strategies&#x27;, routes.resolutionStrategies(_self));
                        app.get(&#x27;/history/endpoints&#x27;, routes.history(_self));
                        app.get(&#x27;/history/endpoints/:id&#x27;, routes.history(_self));
                        app.get(&#x27;/history/endpoints/:from/:to&#x27;, routes.history(_self));
                        app.get(&#x27;/history/endpoints/:id/:from/:to&#x27;, routes.history(_self));
                        app.get(&#x27;/console&#x27;, function (req, res) {
                            res.render(&#x27;console&#x27;);
                        });

                        // put here the route extensions
                        _.each(options.routeExts, function (routeExt) {
                            app.use(routeExt.path, routeExt.route(registry));
                        });
                    }
                });

                // Retrieve stored endpoints
                var storedEnpoints = this._getStoredEndpoints();
                // Concat stored and configured endpoints
                var endpoints = options.endpoints.concat(storedEnpoints);
                // Register service endpoint
                _.each(endpoints, function (endpoint) {
                    _self.addEndpoint(endpoint, false, function (err, endpoint) {
                        if (err) {
                            logger.error(&#x27;Endpoint \&#x27;&#x27; + endpoint.id + &#x27;\&#x27; registration failed: &#x27; + err.message);
                        }
                    });
                });
                logger.info(&#x27;Properties are successfully loaded: &#x27; + JSON.stringify(options));
            } else {
                logger.error(&#x27;validation errors:&#x27;);
                _.each(serverValErrors, function (error) {
                    logger.error(error);
                });
                _self.stop();
            }
            _self.emitter.emit(wjsConfigured);
            return _self;
        },

        /**
         * Starts the Watcher.
         *
         * @method start
         */
        start: _.once(function start() {
            var _self = this;
            _self._stopped = false;
            _self._setup();

            var port = _self.options.port,
                host = _self.options.host,
                interval = _self.options.interval;

            _self.server.start(function () {
                _self.emitter.emit(wjsReady);
                logger.info(&#x27;Watcher is up and running (host/port/interval): (&#x27; +
                host + &#x27;/&#x27; + port + &#x27;/&#x27; + interval + &#x27;)&#x27;);
                setTimeout(_.bind(_self._pollEndpoints, _self), 0).unref();
            });

            var io = _self.server.io;
            io.on(&#x27;connection&#x27;, function (socket) {
                socket.emit(wjsConnected, { message: &#x27;connected with watcher.js&#x27; });
            });
            _self.emitter.on(endpointsStatusResolved, function() {
                io.emit(wjsEndpointsUpdated, { message: &#x27;endpoints data updated!&#x27; });
            });

            _self.db = dbConnFactory.create(_self.options.dbConnectionURL);
            return _self;
        }),

        /**
         * Stops the Watcher.
         *
         * @method stop
         */
        stop: _.once(function stop() {
            logger.info(&#x27;Shutting down Watcher app...&#x27;);
            var _self = this;
            _self._stopped = true;
            async.parallel([
                function (callback) {
                    //insert new entries with &#x27;undetermined&#x27;
                    var entries = [];
                    var now = moment.utc();
                    _.each(_self.getEndpoints(), function (endpoint) {
                        if (undetermined !== endpoint.status) {
                            entries.push({
                                endpointId: endpoint.id,
                                timestamp: now.valueOf(),
                                statusTransition: {
                                    from: endpoint.status,
                                    to: undetermined
                                }
                            });
                        }
                    });
                    _self.db.history.insert(entries, function (err, docs) {
                        callback(err);
                        _self.db.close();
                    });
                },
                asyncTimeout(function (callback) {
                    _self.server.stop();
                }, 2000, &#x27;Give 2 secs to shutdown http server&#x27;)
            ], function (err, results) {
                if (err) {
                    logger.info(&#x27;Shutdown performed with errors: &#x27; + err);
                } else {
                    logger.info(&#x27;Shutdown successfully performed&#x27;);
                }
                process.exit();
            });
            //process.kill(process.pid, &#x27;SIGHUP&#x27;);
        }),

        /**
         * Add listener specific events of the Watcher.
         *
         * @method addListener
         * @param {String} event the event.
         * @param {Object} listener the listener.
         */
        addListener: function addListener(event, listener) {
            this.emitter.on(event, listener);
        }

    }
);

/**
 * Watcher factory.
 * @class WatcherFactory
 * @static
 */
watcherFactory = {
    /**
     * Creates a Watcher instance.
     * @static
     * @method create
     * @param {Object} [options] the Watcher configuration.
     * @example __Options configuration details__.
     * Properties in _[]_ are optional. when not set, the default values are used - those in parentheses.
     * * Embedded http server configuration and service communication interval
     *  * [__host__] (&#x27;localhost&#x27;), the http server host name.
     *  * [__port__] (7777), the http server port.
     *  * [__interval__] (10000 ms), the service communication interval, at ms.
     *  * [__routeExts__], an array of user defined route extensions for building custom responses for the status requests.
     *  * [__resolutionStrategies__], an array of _unbound resolution strategy descriptors_.
     *  The descriptor is an object as follows:
     *  &#x60;&#x60;&#x60;
     *  {
     *      id: &lt;the resolution strategy id&gt;, (should be unique)
     *      desc: &lt;the resolution strategy description&gt;
     *      implementation: &lt;the implementation of resolution strategy&gt; (see at resolvers to see the interface)
     *  }
     *  &#x60;&#x60;&#x60;
     *  * [__nfOpts__], the notification options. Holds the information of the sender and the email addresses
     *  to receive email when erroneous service status occurs. The default sender is _admin@watcherjs.com_
     *  (if needed, configure your email account to not filter this sender as a spam). The object structure is:
     *  &#x60;&#x60;&#x60;
     *  {
     *      sender: &lt;the sender&gt;, // default value: admin@watcherjs.com
     *      recipients: [&lt;recipient1&gt;, &lt;recipient1&gt;, ...] // the array of recipients email
     *  }
     *  &#x60;&#x60;&#x60;
     *  * [__exportDir__] (_&lt;&#x60;project directory&#x60;&gt;/storage/_), the storage directory of dynamically created endpoints.
     *  * [__dbConnectionURL__] (_&#x27;mongodb://localhost:27017/&#x27;_), the connection url of history persistent storage
     *  (currently, the mongoDB is used)
     *
     *
     * * Endpoint
     *  * __id__, the unique endpoint id.
     *  * __type__, the endpoint type.
     *  * [__host__] (localhost), the endpoint hostname, applied for __{{#crossLink &quot;SocketConnector&quot;}}{{/crossLink}}__.
     *  * [__port__] (9999), the endpoint port, applied for __{{#crossLink &quot;SocketConnector&quot;}}{{/crossLink}}__.
     *  * [__url__] (http://localhost:8080), the endpoint url, applied for __{{#crossLink &quot;HttpConnector&quot;}}{{/crossLink}}__.
     *  * [__timeout__](5000), the applied connector&#x27;s connection timeout.
     *  * [__resolutionStrategy__] (__{{#crossLink &quot;OnConnectionResolution&quot;}}{{/crossLink}}__) the applied resolution
     *  strategy, either as an implementation of a resolution strategy or as a reference id of an unbound strategy.
     *  * [__active__] (true), whether or not the endpoint should be activated (enables or suspends
     *  the communication between the respective connector and the endpoint).
     *  * [__notify__] (false), used to indicate whether or not to receive email notifications for
     *  erroneous service status.
     *
     * More details at __{{#crossLinkModule &quot;watcher&quot;}}{{/crossLinkModule}}__.
     *
     * @return {Watcher} the Watcher instance.
     */
    create: function create(options) {
        var _options = {
            port: 7777,
            host: &#x27;localhost&#x27;,
            interval: 10000,
            routeExts: [],
            resolutionStrategies: [],
            nfOpts: {},
            exportDir: __dirname + &#x27;/../storage&#x27;,
            dbConnectionURL: &#x27;mongodb://localhost:27017/&#x27;,
            endpoints: []
        };
        options = options || {};
        _.defaults(options, _options);
        options.nfOpts.sender = options.nfOpts.sender || &#x27;admin@watcherjs.com&#x27;;
        options.exportDir = path.normalize(options.exportDir);
        return watcher.create({
            options: options,
            emitter: new events.EventEmitter()
        });
    }
};

/**
 * Exported module object
 */
module.exports = {
    watcherFactory: watcherFactory
};

    </pre>
</div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
